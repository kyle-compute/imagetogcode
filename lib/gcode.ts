import { CurveSegment } from "./curve-fitting";

export interface Point {
  x: number;
  y: number;
}

export type Path = Point[];

export function generateGCode(paths: Path[], scale: number): string {
  let gcode = "";
  
  // Header - Setup and initialization
  gcode += "; Generated by Professional Vectorization Engine\n";
  gcode += "; Advanced curve fitting with G2/G3 arc support\n";
  gcode += "G21 ; Set units to millimeters\n";
  gcode += "G90 ; Use absolute positioning\n";
  gcode += "G92 X0 Y0 Z0 ; Set current position as origin\n";
  gcode += "G1 F1500 ; Set drawing feed rate (slower for precision)\n";
  gcode += "G0 F3000 ; Set rapid move feed rate\n";
  gcode += "G0 Z5 ; Initial pen lift\n";
  gcode += "\n";

  let pathCount = 0;
  const scaleFactor = scale / 100;

  for (const path of paths) {
    if (path.length < 2) continue; // Skip single points
    
    pathCount++;
    gcode += `; Path ${pathCount} - ${path.length} points\n`;

    const startPoint = path[0];
    
    // Move to start position with pen up
    gcode += `G0 Z5 ; Lift pen\n`;
    gcode += `G0 X${(startPoint.x * scaleFactor).toFixed(3)} Y${(startPoint.y * scaleFactor).toFixed(3)} ; Move to start\n`;
    gcode += `G1 Z0 ; Lower pen\n`;

    // Draw the path with higher precision
    for (let i = 1; i < path.length; i++) {
      const point = path[i];
      gcode += `G1 X${(point.x * scaleFactor).toFixed(3)} Y${(point.y * scaleFactor).toFixed(3)}\n`;
    }
    
    gcode += "\n";
  }

  // Footer - Safe ending
  gcode += "; End of drawing\n";
  gcode += "G0 Z5 ; Final pen lift\n";
  gcode += "G0 X0 Y0 ; Return to origin\n";
  gcode += "M30 ; End program\n";
  
  // Add statistics
  gcode += `; Statistics: ${pathCount} paths, ${paths.reduce((sum, path) => sum + path.length, 0)} total points\n`;

  return gcode;
}

/**
 * Advanced G-code generation with curve support
 * Generates smooth G2/G3 arcs and approximated Bézier curves
 */
export function generateAdvancedGCode(
  curves: CurveSegment[], 
  scale: number,
  options: {
    enableArcs?: boolean;
    bezierResolution?: number;
    arcTolerance?: number;
  } = {}
): string {
  const {
    enableArcs = true,
    bezierResolution = 10,
    arcTolerance = 0.1
  } = options;
  
  let gcode = "";
  const scaleFactor = scale / 100;
  
  // Enhanced header
  gcode += "; Generated by Professional Vectorization Engine\n";
  gcode += "; Advanced curve fitting with G2/G3 arc support\n";
  gcode += "; Smooth curves for superior print quality\n";
  gcode += "G21 ; Set units to millimeters\n";
  gcode += "G90 ; Use absolute positioning\n";
  gcode += "G92 X0 Y0 Z0 ; Set current position as origin\n";
  gcode += "G1 F1200 ; Set drawing feed rate (optimized for curves)\n";
  gcode += "G0 F3000 ; Set rapid move feed rate\n";
  gcode += "G0 Z5 ; Initial pen lift\n";
  gcode += "\n";

  let curveCount = 0;
  let arcCount = 0;
  let bezierCount = 0;

  for (const curve of curves) {
    curveCount++;
    gcode += `; Curve ${curveCount} - Type: ${curve.type}\n`;

    const startPoint = curve.start;
    
    // Move to start position with pen up
    gcode += `G0 Z5 ; Lift pen\n`;
    gcode += `G0 X${(startPoint.x * scaleFactor).toFixed(3)} Y${(startPoint.y * scaleFactor).toFixed(3)} ; Move to start\n`;
    gcode += `G1 Z0 ; Lower pen\n`;

    if (curve.type === 'arc' && enableArcs) {
      // Generate G2/G3 arc command
      const arc = curve;
      const endX = arc.end.x * scaleFactor;
      const endY = arc.end.y * scaleFactor;
      const centerOffsetX = (arc.center.x - arc.start.x) * scaleFactor;
      const centerOffsetY = (arc.center.y - arc.start.y) * scaleFactor;
      
      const gCommand = arc.clockwise ? 'G2' : 'G3';
      gcode += `${gCommand} X${endX.toFixed(3)} Y${endY.toFixed(3)} I${centerOffsetX.toFixed(3)} J${centerOffsetY.toFixed(3)} ; Arc radius ${(arc.radius * scaleFactor).toFixed(2)}\n`;
      arcCount++;
      
    } else if (curve.type === 'bezier') {
      // Approximate Bézier curve with line segments or arcs
      const bezier = curve;
      
      if (enableArcs) {
        // Try to approximate with arcs first
        const arcApproximation = approximateBezierWithArcs(bezier, arcTolerance * scaleFactor);
        if (arcApproximation.length > 0) {
          for (const arcSeg of arcApproximation) {
            const endX = arcSeg.end.x * scaleFactor;
            const endY = arcSeg.end.y * scaleFactor;
            const centerOffsetX = (arcSeg.center.x - arcSeg.start.x) * scaleFactor;
            const centerOffsetY = (arcSeg.center.y - arcSeg.start.y) * scaleFactor;
            
            const gCommand = arcSeg.clockwise ? 'G2' : 'G3';
            gcode += `${gCommand} X${endX.toFixed(3)} Y${endY.toFixed(3)} I${centerOffsetX.toFixed(3)} J${centerOffsetY.toFixed(3)} ; Bezier arc approx\n`;
          }
          arcCount += arcApproximation.length;
        } else {
          // Fallback to line segments
          const points = sampleBezierCurve(bezier, bezierResolution);
          for (let i = 1; i < points.length; i++) {
            const point = points[i];
            gcode += `G1 X${(point.x * scaleFactor).toFixed(3)} Y${(point.y * scaleFactor).toFixed(3)}\n`;
          }
        }
      } else {
        // Use line segments for Bézier curves
        const points = sampleBezierCurve(bezier, bezierResolution);
        for (let i = 1; i < points.length; i++) {
          const point = points[i];
          gcode += `G1 X${(point.x * scaleFactor).toFixed(3)} Y${(point.y * scaleFactor).toFixed(3)}\n`;
        }
      }
      bezierCount++;
    }
    
    gcode += "\n";
  }

  // Enhanced footer with detailed statistics
  gcode += "; End of drawing\n";
  gcode += "G0 Z5 ; Final pen lift\n";
  gcode += "G0 X0 Y0 ; Return to origin\n";
  gcode += "M30 ; End program\n";
  gcode += "\n";
  gcode += `; Advanced Statistics:\n`;
  gcode += `; Total curves: ${curveCount}\n`;
  gcode += `; G2/G3 arcs: ${arcCount}\n`;
  gcode += `; Bézier curves: ${bezierCount}\n`;
  gcode += `; Arc support: ${enableArcs ? 'enabled' : 'disabled'}\n`;
  gcode += `; Scale factor: ${scaleFactor.toFixed(3)}\n`;

  return gcode;
}

/**
 * Sample points along a Bézier curve
 */
function sampleBezierCurve(bezier: any, resolution: number): Point[] {
  const points: Point[] = [];
  
  for (let i = 0; i <= resolution; i++) {
    const t = i / resolution;
    const point = evaluateBezier(bezier, t);
    points.push(point);
  }
  
  return points;
}

/**
 * Evaluate Bézier curve at parameter t
 */
function evaluateBezier(curve: any, t: number): Point {
  const { start, control1, control2, end } = curve;
  const u = 1 - t;
  const tt = t * t;
  const uu = u * u;
  const uuu = uu * u;
  const ttt = tt * t;
  
  return {
    x: uuu * start.x + 3 * uu * t * control1.x + 3 * u * tt * control2.x + ttt * end.x,
    y: uuu * start.y + 3 * uu * t * control1.y + 3 * u * tt * control2.y + ttt * end.y
  };
}

/**
 * Approximate a Bézier curve with one or more circular arcs
 * This enables smooth G2/G3 output for complex curves
 */
function approximateBezierWithArcs(bezier: any, tolerance: number): any[] {
  // Sample the Bézier curve to analyze its shape
  const samples = 20;
  const points: Point[] = [];
  
  for (let i = 0; i <= samples; i++) {
    const t = i / samples;
    points.push(evaluateBezier(bezier, t));
  }
  
  // Try to fit a single arc to the entire curve
  const singleArc = fitArcToPoints(points);
  if (singleArc && calculateArcError(points, singleArc) <= tolerance) {
    return [singleArc];
  }
  
  // If single arc fails, try splitting into two arcs
  const midPoint = Math.floor(samples / 2);
  const firstHalf = points.slice(0, midPoint + 1);
  const secondHalf = points.slice(midPoint);
  
  const arc1 = fitArcToPoints(firstHalf);
  const arc2 = fitArcToPoints(secondHalf);
  
  if (arc1 && arc2 && 
      calculateArcError(firstHalf, arc1) <= tolerance &&
      calculateArcError(secondHalf, arc2) <= tolerance) {
    return [arc1, arc2];
  }
  
  // If arc fitting fails, return empty array to fall back to line segments
  return [];
}

/**
 * Fit a circular arc to a set of points
 */
function fitArcToPoints(points: Point[]): any | null {
  if (points.length < 3) return null;
  
  // Use three points to define the arc: start, middle, end
  const start = points[0];
  const middle = points[Math.floor(points.length / 2)];
  const end = points[points.length - 1];
  
  // Find circle center using perpendicular bisectors
  const center = findCircleCenter(start, middle, end);
  if (!center) return null;
  
  const radius = distance(start, center);
  
  // Determine if arc is clockwise
  const startToMid = { x: middle.x - start.x, y: middle.y - start.y };
  const startToEnd = { x: end.x - start.x, y: end.y - start.y };
  const cross = startToMid.x * startToEnd.y - startToMid.y * startToEnd.x;
  
  return {
    start,
    end,
    center,
    radius,
    clockwise: cross < 0,
    type: 'arc'
  };
}

/**
 * Find the center of a circle passing through three points
 */
function findCircleCenter(p1: Point, p2: Point, p3: Point): Point | null {
  const ax = p1.x, ay = p1.y;
  const bx = p2.x, by = p2.y;
  const cx = p3.x, cy = p3.y;
  
  const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
  if (Math.abs(d) < 1e-10) return null; // Points are collinear
  
  const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
  const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;
  
  return { x: ux, y: uy };
}

/**
 * Calculate error between points and arc approximation
 */
function calculateArcError(points: Point[], arc: any): number {
  let maxError = 0;
  
  for (const point of points) {
    const distToCenter = distance(point, arc.center);
    const error = Math.abs(distToCenter - arc.radius);
    maxError = Math.max(maxError, error);
  }
  
  return maxError;
}

/**
 * Calculate distance between two points
 */
function distance(p1: Point, p2: Point): number {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
